{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Project documentation homepage","text":"<p>This project contains utility code to use between projects, you can either download all the code, or just grab the parts you need for your project.</p> <p>The project contains documentation on</p> <ul> <li>python</li> <li>c++</li> <li>git</li> </ul>"},{"location":"cpp_image/","title":"Image handling in C++","text":""},{"location":"cpp_image/#include-stb-for-image-handling","title":"Include stb for image handling","text":"<pre><code>#define STB_IMAGE_WRITE_IMPLEMENTATION\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb/stb_image.h\"\n#include \"stb/stb_image_write.h\"\n</code></pre>"},{"location":"cpp_image/#image-handling-in-c_1","title":"Image handling in c++","text":"<p>Requires that you have included stb</p> <pre><code>struct ColorRGBA_UChar {\n    unsigned char r = 0;\n    unsigned char g = 0;\n    unsigned char b = 0;\n    unsigned char a = 0;\n    ColorRGBA_UChar(){}\n    ColorRGBA_UChar(int r_, int g_, int b_, int a_) {\n        r = r_;\n        g = g_;\n        b = b_;\n        a = a_;\n    }\n    std::string to_string() {\n        return vicmil::vec_to_str&lt;int&gt;({r, g, b});\n    }\n    bool operator==(const ColorRGBA_UChar&amp; other) const {\n        return  r == other.r &amp;&amp; \n                g == other.g &amp;&amp; \n                b == other.b &amp;&amp; \n                a == other.a;\n    }\n}\n\nstruct ImageRGBA_UChar {\n    int w;\n    int h;\n    std::vector&lt;ColorRGBA_UChar&gt; pixels;\n    void resize(unsigned int new_width, unsigned int new_height) {\n        pixels.resize(new_width * new_height)\n    }\n    ColorRGBA_UChar* get_pixel(int x, int y) {\n        return &amp;pixels[y * width + x]\n    }\n    unsigned char* get_pixel_data() {\n        return (unsigned char*)((void*)(&amp;pixels[0]));\n    }\n    void set_pixel_data(unsigned char* data, int byte_count) {\n        assert(byte_count == pixels.size() * sizeof(ColorRGBA_UChar));\n        std::memcpy(&amp;pixels[0], data, byte_count);\n    }\n\n    static void load_png_from_file(std::string filename, ImageRGBA_UChar&amp; return_image) const {\n        // If it failed to load the file, the width will be zero for the returned image object\n        int w = 0;\n        int h = 0;\n        int n = 0;\n        int comp = 4; // r, g, b, a\n        unsigned char *data = stbi_load(filename.c_str(), &amp;w, &amp;h, &amp;n, comp);\n        return_image.resize(w, h);\n        if(w != 0) {\n            return_image.set_pixel_data(data, w * h * 4);\n        }\n        stbi_image_free(data);\n    }\n    void save_as_png(std::string filename) const {\n        int comp = 4; // r, g, b, a\n        const void *data = get_pixel_data();\n        int stride_in_bytes = 0;\n        stbi_write_png(filename.c_str(), width, height, comp, data, stride_in_bytes);\n    }\n\n    std::vector&lt;unsigned char&gt; to_png_as_bytes(Image&lt;ColorRGBA_UChar&gt;&amp; image) const {\n        int comp = 4; // r, g, b, a\n        void* data = get_pixel_data();\n        int stride_in_bytes = 0;\n        stbi_write_func&amp; write_func = _write_to_vector;\n\n        std::unique_ptr&lt;std::vector&lt;unsigned char&gt;&gt; vec = std::make_unique&lt;std::vector&lt;unsigned char&gt;&gt;();\n        std::vector&lt;unsigned char&gt;* vec_ptr = vec.get();\n        stbi_write_png_to_func(write_func, vec_ptr, width, height, comp, data, stride_in_bytes);\n        return *vec;\n    }\n    static void png_as_bytes_to_image(const unsigned char* bytes, int length, ImageRGBA_UChar&amp; return_image) {\n        int w;\n        int h;\n        int n;\n        int comp = 4; // r, g, b, a\n\n        unsigned char *data = stbi_load_from_memory(bytes, length, &amp;w, &amp;h, &amp;n, comp);\n        return_image.resize(w, h);\n        return_image.set_pixel_data(data, w * h * 4);\n        stbi_image_free(data);\n        return new_image;\n    }\n    static void png_as_bytes_to_image(const std::vector&lt;unsigned char&gt;&amp; data, ImageRGBA&amp; return_image) {\n        return png_as_bytes_to_image(&amp;data[0], data.size(), return_image);\n    }\n};\n</code></pre>"},{"location":"cpp_image/#loading-fonts-in-c","title":"Loading fonts in c++","text":"<p>Note! Code is not tested, so it will probably contain some bugs</p> <pre><code>#define STB_TRUETYPE_IMPLEMENTATION \n#include \"stb/stb_truetype.h\"\n</code></pre> <pre><code>// For loading true type fonts (.ttf)\nstruct FontLoader {\n    stbtt_fontinfo info;\n    std::vector&lt;unsigned char&gt; font_data;\n\n    // Calculated from line height\n    int line_height;\n    float scale;\n    int ascent; // Line spacing in y direction\n    int descent;\n    int lineGap;\n\n    void load_font_from_memory(unsigned char* fontBuffer_, int size, int line_height_=64) {\n        // Load font into buffer\n        font_data.resize(size);\n        memcpy(&amp;font_data[0], fontBuffer_, size);\n\n        // Prepare font\n        if (!stbtt_InitFont(&amp;info, &amp;font_data[0], 0))\n        {\n            printf(\"failed\\n\");\n        }\n        set_line_height(line_height_); // Set default line height\n    }\n    void load_font_from_file(std::string filepath, int line_height_=64) {\n        vicmil::FileManager file = vicmil::FileManager(filepath);\n        std::vector&lt;char&gt; data = file.read_entire_file();\n        load_font_from_memory((unsigned char*)&amp;data[0], data.size(), line_height_);\n    }\n\n    void set_line_height(int new_line_height) {\n        line_height = new_line_height;\n        scale = stbtt_ScaleForPixelHeight(&amp;info, line_height);\n        int ascent; // Line spacing in y direction\n        int descent;\n        int lineGap;\n        stbtt_GetFontVMetrics(&amp;info, &amp;ascent, &amp;descent, &amp;lineGap);\n        ascent = roundf(ascent * scale);\n        descent = roundf(descent * scale);\n    }\n\n    void _get_character_advancement(const int character, int* advanceWidth, int* leftSideBearing) {\n        // Advance width is how much to advance to the right\n        // leftSideBearing means that it overlaps a little with the previous character\n        stbtt_GetCodepointHMetrics(&amp;info, character, advanceWidth, leftSideBearing);\n        *advanceWidth = roundf(*advanceWidth * scale);\n        *leftSideBearing = roundf(*leftSideBearing * scale);\n    }\n\n    int _get_kernal_advancement(const int character1, const int character2) {\n        int kern = stbtt_GetCodepointKernAdvance(&amp;info, character1, character2);\n        return roundf(kern * scale);\n    }\n\n    RectT&lt;int&gt; _get_character_bounding_box(const int character) {\n        int ax;\n        int lsb;\n        stbtt_GetCodepointHMetrics(&amp;info, character, &amp;ax, &amp;lsb);\n\n        // Get bounding box for character (may be offset to account for chars that dip above or below the line)\n        int c_x1, c_y1, c_x2, c_y2;\n        stbtt_GetCodepointBitmapBox(&amp;info, character, scale, scale, &amp;c_x1, &amp;c_y1, &amp;c_x2, &amp;c_y2);\n        return RectT&lt;int&gt;(c_x1, c_y1, c_x2 - c_x1, c_y2 - c_y1);\n    }\n\n    // Get image of character\n    Image&lt;unsigned char&gt; get_character_image(const int character) {\n        RectT&lt;int&gt; bounding_box = _get_character_bounding_box(character);\n        Image&lt;unsigned char&gt; return_image = Image&lt;unsigned char&gt;();\n        return_image.resize(bounding_box.w, bounding_box.h, 127);\n        stbtt_MakeCodepointBitmap(&amp;info, (unsigned char*)&amp;return_image.pixels[0], bounding_box.w, bounding_box.h, bounding_box.w, scale, scale, character);\n        return return_image;\n    }\n\n    Image&lt;ColorRGBA_UChar&gt; get_character_image_rgba(const int character, ColorRGBA_UChar color_mask=ColorRGBA_UChar(255, 255, 255, 255)) {\n        Image&lt;unsigned char&gt; character_image = get_character_image(character);\n        Image&lt;ColorRGBA_UChar&gt; return_image;\n        return_image.resize(character_image.width, character_image.height);\n        for(int x = 0; x &lt; character_image.width; x++) {\n            for(int y = 0; y &lt; character_image.height; y++) {\n                unsigned int pixel_index = character_image.get_pixel_index(x, y);\n                int v = character_image.pixels[pixel_index];\n                int r = (color_mask.r * v) / 255;\n                int g = (color_mask.g * v) / 255;\n                int b = (color_mask.b * v) / 255;\n                int a = color_mask.a;\n                return_image.pixels[pixel_index] = ColorRGBA_UChar(r, g, b, a);\n            }\n        }\n        return return_image;\n    }\n\n    // Get where font images in a text should be placed. \n    // Some fonts may take into consideration which letters are next to each other, so-called font kerning\n    // Characters are specified in unicode(but normal ascii will be treated as usual)\n    std::vector&lt;RectT&lt;int&gt;&gt; get_character_image_positions(const std::vector&lt;int&gt; characters) {\n        std::vector&lt;RectT&lt;int&gt;&gt; return_vec = {};\n        return_vec.reserve(characters.size());\n\n        int x = 0;\n        for(int i = 0; i &lt; characters.size(); i++) {\n            // Get bounding box for character\n            RectT&lt;int&gt; image_pos = _get_character_bounding_box(characters[i]);\n            image_pos.x += x;\n            image_pos.y += ascent;\n\n            int advanceWidth;\n            int leftSideBearing;\n            _get_character_advancement(characters[i], &amp;advanceWidth, &amp;leftSideBearing);\n            image_pos.x += leftSideBearing;\n\n            // Push back bounding box\n            return_vec.push_back(image_pos);\n\n            // Increment position if there is another letter after\n            if(i + 1 != characters.size()) {\n                x += advanceWidth;\n                x += _get_kernal_advancement(characters[i], characters[i + 1]);\n            }\n        }\n        return return_vec;\n    }\n\n    // Get the glyph index of character\n    // (Can be used to determine if two letters correspond to the same font image)\n    int get_glyph_index(const int character) {\n        int glyphIndex = stbtt_FindGlyphIndex(&amp;info, character);\n        if (glyphIndex == 0) {\n            Debug(\"Glyph not found for codepoint: \" &lt;&lt; character);\n        }\n        return glyphIndex;\n    }\n    // Determine if a letter/character/unicode character is a part of the loaded font\n    bool character_is_part_of_font(const int character) {\n        return get_glyph_index(character) != 0;\n    }\n};\n</code></pre> <pre><code>// Example\nFontLoader font_loader = FontLoader();\nfont_loader.load_font_from_file(\"my_font.ttf\")\nImage&lt;unsigned char&gt; my_image = font_loader.get_character_image(\"a\");\nmy_image.to_png_file(\"letter_a.png\");\n</code></pre>"},{"location":"cpp_opengl/","title":"Graphics using opengl","text":"<p>TODO: Add more documentation</p>"},{"location":"cpp_std/","title":"Contains documentation for how to do some things using the standard library","text":"<p>Everything should be supported in C++11 and newer versions across most major platforms(Windows, Linux, Browser using emscripten)</p> <p>You can either just copy the parts that you find interesting, or download the following:</p> <ul> <li>util_std.hpp</li> <li>cpp_build.py</li> <li>util_std_example.cpp</li> <li>cpp_build_example.py</li> </ul> <p>Some other files that might be nice to have</p> <ul> <li>mingw-std-threads.zip - enable threading for mingw, originally from: https://github.com/meganz/mingw-std-threads</li> <li>mingw64.zip - c++ compiler for windows</li> </ul>"},{"location":"cpp_std/#cross-platform-headers","title":"Cross-platform headers","text":"<pre><code>/**\n * These are a list of **most** cross-platform c++11 headers\n*/\n#pragma once\n#include &lt;iostream&gt;     // For cout, cin and in other ways interracting with the terminal\n#include &lt;fstream&gt;\n#include &lt;sstream&gt;\n#include &lt;filesystem&gt;   // For reading and writing files\n\n#include &lt;string&gt;       // Contains std::string\n#include &lt;set&gt;          // Contains std::set\n#include &lt;map&gt;          // contains std::map\n#include &lt;vector&gt;       // Contains std::vector\n#include &lt;list&gt;         // Contains std::list\n\n#include &lt;math.h&gt;       // Includes basic math operations such as sinus, cosinus etc.\n#include &lt;cassert&gt;      // For assering values during runtime\n#include &lt;regex&gt;        // Includes functions for regex\n#include &lt;chrono&gt;       // Includes functions related to time \n#ifdef __MINGW64__      // For supporting multi-thread applications on windows when compiling using mingw\n#include \"mingw-std-threads/mingw.thread.h\"\n#else\n#include &lt;thread&gt;       // Includes functions for handling multi-thread applications\n#endif\n#include &lt;complex.h&gt;    // For supporting complex number operations\n\n#include &lt;typeindex&gt;    // For getting the index of different types, and other type information\n#include &lt;random&gt;       // For generating random numbers\n\n#ifdef __EMSCRIPTEN__\n#include \"emscripten.h\" // Include emscripten if available, needed to set the main loop function in case of emscripten\n#endif\n\n#ifdef __unix__                             /* __unix__ is usually defined by compilers targeting Unix systems */\n    #define OS_Linux\n#elif defined(_WIN32) || defined(WIN32)     /* _Win32 is usually defined by compilers targeting 32 or   64 bit Windows systems */\n    #define OS_Windows\n#endif\n</code></pre>"},{"location":"cpp_std/#automatic-tests-in-c","title":"Automatic tests in c++","text":"<pre><code>typedef void (*void_function_type)();\n\ntypedef std::map&lt;std::string, struct TestClass*&gt; __test_map_type__;\nstatic __test_map_type__* __test_map__ = nullptr;\n\nstruct TestClass {\n    std::string _id_long;\n    virtual void test() {}\n    virtual ~TestClass() {}\n    TestClass(std::string id, std::string id_long) {\n        if ( !__test_map__ ) {\n            __test_map__ = new __test_map_type__();\n        }\n        (*__test_map__)[id] = this;\n        _id_long = id_long;\n    }\n    static void run_all_tests(std::vector&lt;std::string&gt; test_keywords = {}) {\n        if(!__test_map__) {\n            std::cout &lt;&lt; \"No tests detected!\" &lt;&lt; std::endl;\n            return;\n        }\n        __test_map_type__::iterator it = __test_map__-&gt;begin();\n        while(it != __test_map__-&gt;end()) {\n            std::pair&lt;const std::string, TestClass*&gt; val = *it;\n            it++;\n            std::string test_name = val.first;\n            std::cout &lt;&lt; \"&lt;&lt;&lt;&lt;&lt;&lt;&lt; run test: \" &lt;&lt; test_name &lt;&lt; \"&gt;&gt;&gt;&gt;&gt;&gt;&gt;\";\n                try {\n                    val.second-&gt;test();\n                }\n                catch (const std::exception&amp; e) {\n                    std::cout &lt;&lt; \"caught error\" &lt;&lt; std::endl;\n                    std::cout &lt;&lt; e.what(); // information from error printed\n                    exit(1);\n                }\n                catch(...) {\n                    std::cout &lt;&lt; \"caught unknown error\" &lt;&lt; std::endl;\n                    exit(1);\n                } \n            std::cout &lt;&lt; \"test passed!\" &lt;&lt; std::endl;\n        }\n        std::cout &lt;&lt; \"All tests passed!\" &lt;&lt; std::endl;\n    }\n};\n\n#define TestWrapper(test_name, func) \\\nnamespace test_class { \\\n    struct test_name : vicmil::TestClass { \\\n        test_name() : vicmil::TestClass(LINE_INFO.to_string_with_func_name(), LINE_INFO.to_long_string()) {} \\\n        func \\\n    }; \\\n} \\\nnamespace test_factory { \\\n    test_class::test_name test_name = test_class::test_name(); \\\n}\n\n/**\n * Add a test to be executed\n*/\n#define AddTest(test_name) \\\nTestWrapper(test_name ## _, \\\nvoid test() { \\\n    test_name(); \\\n} \\\n);\n</code></pre> <pre><code>void add_(int x, int y) {\n    return x + y;\n}\n\n// Add a test for the function\nvoid TEST_add_() {\n    assert(add_(1, 2) == 3);\n}\nAddTest(TEST_add_);\n\n// Run all tests\nint main() {\n    vicmil::TestClass::run_all_tests();\n    return 0;\n}\n</code></pre>"},{"location":"cpp_std/#vector-to-string","title":"Vector to string","text":"<pre><code>/*\nConvert a vector of something into a string\nexample: \"{123.321, 314.0, 42.0}\"\n*/\ntemplate&lt;class T&gt;\nstd::string vec_to_str(const std::vector&lt;T&gt;&amp; vec) {\n    std::string out_str;\n    out_str += \"{ \";\n    for(int i = 0; i &lt; vec.size(); i++) {\n        if(i != 0) {\n            out_str += \", \";\n        }\n        out_str += std::to_string(vec[i]);\n    }\n    out_str += \" }\";\n    return out_str;\n}\n\n/*\nConvert a vector of strings into a single string\n[\"a\", \"b\"] -&gt; \"{'a', 'b'}\"\n*/\nstd::string vec_to_str(const std::vector&lt;std::string&gt;&amp; vec) {\n    std::string return_str = \"{\";\n    for(int i = 0; i &lt; vec.size(); i++) {\n        if(i != 0) {\n            return_str += \", \";\n        }\n        return_str += \"'\" + vec[i] + \"'\";\n    }\n    return_str += \" }\";\n    return return_str;\n}\n</code></pre>"},{"location":"cpp_std/#convert-to-binary","title":"Convert to binary","text":"<pre><code>/**\n * Takes an arbitrary type and converts it to binary, eg string of 1:s and 0:es\n*/\ntemplate&lt;class T&gt;\nstd::string to_binary_str(T&amp; value) {\n    int size_in_bytes = sizeof(T);\n    char* bytes = (char*)&amp;value;\n    std::string return_str;\n    for(int i = 0; i &lt; size_in_bytes; i++) {\n        if(i != 0) {\n            return_str += \" \";\n        }\n        for(int j = 0; j &lt; 8; j++) {\n            if((bytes[i] &amp; (1&lt;&lt;j)) == 0) {\n                return_str += \"0\";\n            }\n            else {\n                return_str += \"1\";\n            }\n        }\n    }\n    return return_str;\n}\n</code></pre>"},{"location":"cpp_std/#string-replace","title":"String replace","text":"<pre><code>/**\n * Replaces each instance of a str_from to str_to inside str\n * @param str the main string\n * @param str_from the pattern string we would like to replace\n * @param str_to what we want to replace str_from with\n*/\ninline std::string string_replace(const std::string&amp; str, const std::string&amp; str_from, const std::string&amp; str_to) {\n    std::string remaining_string = str;\n    std::string new_string = \"\";\n    while(true) {\n        auto next_occurence = remaining_string.find(str_from);\n        if(next_occurence == std::string::npos) {\n            return new_string + remaining_string;\n        }\n        new_string = new_string + remaining_string.substr(0, next_occurence) + str_to;\n        remaining_string = remaining_string.substr(next_occurence + str_from.size(), std::string::npos);\n    }\n}\n</code></pre>"},{"location":"cpp_std/#regex-find-all","title":"Regex find all","text":"<pre><code>std::vector&lt;std::string&gt; regex_find_all(std::string str, std::string regex_expr) {\n    // Wrap regular expression in c++ type\n    std::regex r = std::regex(regex_expr);\n\n    // Iterate to find all matches of regex expression\n    std::vector&lt;std::string&gt; tokens = std::vector&lt;std::string&gt;();\n    for(std::sregex_iterator i = std::sregex_iterator(str.begin(), str.end(), r);\n                            i != std::sregex_iterator();\n                            ++i )\n    {\n        std::smatch m = *i;\n        //std::cout &lt;&lt; m.str() &lt;&lt; \" at position \" &lt;&lt; m.position() &lt;&lt; '\\n';\n        tokens.push_back(m.str());\n    }\n    return tokens;\n}\n</code></pre>"},{"location":"cpp_std/#regex-match","title":"Regex match","text":"<pre><code>bool regex_match_expr(std::string str, std::string regex_expr) {\n    return std::regex_match(str, std::regex(regex_expr));\n}\n</code></pre>"},{"location":"cpp_std/#cut-of-string-after-find","title":"Cut of string after find","text":"<pre><code>inline std::string cut_off_after_find(std::string str, std::string delimiter) {\n    // Find first occurrence\n    size_t found_index = str.find(delimiter);\n\n    // Take substring before first occurance\n    if(found_index != std::string::npos) {\n        return str.substr(0, found_index);\n    }\n    return str;\n}\n\ninline std::string cut_off_after_rfind(std::string str, std::string delimiter) {\n    // Find first occurrence\n    size_t found_index = str.rfind(delimiter);\n\n    // Take substring before first occurance\n    if(found_index != std::string::npos) {\n        return str.substr(0, found_index);\n    }\n    return str;\n}\n</code></pre>"},{"location":"cpp_std/#utf8-support","title":"UTF8 support","text":"<pre><code>/** UTF8 is compatible with ascii, and can be stored in a string(of chars)\n * Since ascii is only 7 bytes, we can have one bit represent if it is a regular ascii\n *  or if it is a unicode character. Unicode characters can be one, two, three or four bytes\n * \n * See https://en.wikipedia.org/wiki/UTF-8 for more info\n**/ \nbool is_utf8_ascii_char(char char_) {\n    return ((char)(1&lt;&lt;7) &amp; char_) == 0;\n}\n\n// Function to convert UTF-8 to a vector of integers representing Unicode code points\nstd::vector&lt;int&gt; utf8ToUnicodeCodePoints(const std::string&amp; utf8String) {\n    std::vector&lt;int&gt; codePoints;\n    size_t i = 0;\n    while (i &lt; utf8String.size()) {\n        unsigned char c = utf8String[i++];\n        int codePoint;\n        if ((c &amp; 0x80) == 0) {\n            codePoint = c;\n        } else if ((c &amp; 0xE0) == 0xC0) {\n            codePoint = ((c &amp; 0x1F) &lt;&lt; 6);\n            codePoint |= (utf8String[i++] &amp; 0x3F);\n        } else if ((c &amp; 0xF0) == 0xE0) {\n            codePoint = ((c &amp; 0x0F) &lt;&lt; 12);\n            codePoint |= ((utf8String[i++] &amp; 0x3F) &lt;&lt; 6);\n            codePoint |= (utf8String[i++] &amp; 0x3F);\n        } else if ((c &amp; 0xF8) == 0xF0) {\n            codePoint = ((c &amp; 0x07) &lt;&lt; 18);\n            codePoint |= ((utf8String[i++] &amp; 0x3F) &lt;&lt; 12);\n            codePoint |= ((utf8String[i++] &amp; 0x3F) &lt;&lt; 6);\n            codePoint |= (utf8String[i++] &amp; 0x3F);\n        }\n        codePoints.push_back(codePoint);\n    }\n    return codePoints;\n}\n</code></pre> <pre><code>void TEST_utf8ToUnicodeCodePoints() {\n    std::string utf8Text = u8\"\u3053\u3093\u306b\u3061\u306ftest\"; // UTF-8 text\n    std::vector&lt;int&gt; codePoints = utf8ToUnicodeCodePoints(utf8Text); // Convert UTF-8 to Unicode code points\n    Assert(codePoints[0] == 12371); // Unicode character for '\u3053'\n    Assert(codePoints[5] == 't') // Unicode/ASCII character for 't'\n    Assert(codePoints.size() == 9);\n}\n</code></pre>"},{"location":"cpp_std/#read-file-contents","title":"Read file contents","text":"<pre><code>/**\n * Read all the contents of a file and return it as a string\n*/\nstd::string read_file_contents(const std::string&amp; filename) {\n    std::ifstream file(filename);\n    std::string contents;\n\n    if (file.is_open()) {\n        // Read the file content into the 'contents' string.\n        std::string line;\n        while (std::getline(file, line)) {\n            contents += line + \"\\n\"; // Add each line to the contents with a newline.\n        }\n        file.close();\n    } else {\n        std::cerr &lt;&lt; \"Error: Unable to open file \" &lt;&lt; filename &lt;&lt; std::endl;\n    }\n\n    return contents;\n}\n</code></pre>"},{"location":"cpp_std/#read-file-contents-line-by-line","title":"Read file contents line by line","text":"<pre><code>/**\n * Read all file contents line by line, and return it as a vector where each index represents a line\n*/\nstd::vector&lt;std::string&gt; read_file_contents_line_by_line(const std::string&amp; filename) {\n    std::ifstream file(filename);\n    std::vector&lt;std::string&gt; contents;\n\n    if (file.is_open()) {\n        // Read the file content into the 'contents' string.\n        std::string line;\n        while (std::getline(file, line)) {\n            contents.push_back(line); // Add each line to the contents with a newline.\n        }\n        file.close();\n    } else {\n        std::cerr &lt;&lt; \"Error: Unable to open file \" &lt;&lt; filename &lt;&lt; std::endl;\n    }\n\n    return contents;\n}\n</code></pre>"},{"location":"cpp_std/#filemanager-for-reading-and-writing-files","title":"FileManager for reading and writing files","text":"<pre><code>/**\n * General file manager for easy file management\n * - Contains a lot of utility functions to make your life easier\n*/\nclass FileManager {\n    std::string filename;\npublic:\n    std::fstream file; // Read &amp; Write\n    //std::ifstream file; // Read only\n    //std::ofstream file; // Write only\n    FileManager(std::string filename_, bool create_file=false) { // class constructor\n        filename = filename_;\n        if(create_file) {\n            file = std::fstream(filename, std::ios::app | std::ios::binary);\n        }\n        else {\n            file = std::fstream(filename, std::ios::in | std::ios::binary | std::ios::out);\n        }\n\n        if(!file_is_open()) {\n            std::cout &lt;&lt; \"file could not open!\" &lt;&lt; std::endl;\n            std::cout &lt;&lt; filename &lt;&lt; std::endl;\n            throw;\n        }\n        else {\n            //std::cout &lt;&lt; \"file opened successfully\" &lt;&lt; std::endl;\n        }\n        }\n    bool file_is_open() {\n        return file.is_open();\n    }\n\n    void set_read_write_position(unsigned int index) {\n        file.seekg(index);\n    }\n    unsigned int get_read_write_position() {\n        // get current read position\n        std::streampos read_pos = file.tellg();\n        return read_pos;\n    }\n\n    std::vector&lt;char&gt; read_bytes(unsigned int read_size_in_bytes) { // read bytes as binary and write into &amp;output\n        std::vector&lt;char&gt; output = std::vector&lt;char&gt;();\n        output.resize(read_size_in_bytes);\n        file.read(&amp;output[0], read_size_in_bytes); // read this many bytes from read_write_position in file, to &amp;output[0] in memory.\n        return output;\n    }\n    std::vector&lt;char&gt; read_entire_file() {\n        unsigned int file_size = get_file_size();\n        set_read_write_position(0);\n        return read_bytes(file_size);\n    }\n    void write_bytes(const unsigned char* data, int size_in_bytes) {\n        file.write((char*)(void*)data, size_in_bytes);\n    }\n    void write_bytes(const std::vector&lt;char&gt;&amp; input) {\n        file.write(&amp;input[0], input.size());\n        // write this many bytes from &amp;input[0] in memory, to read_write_position in file.\n        // also increments read_write_position by the same amount of bytes.\n    }\n    void write_bytes(const std::vector&lt;unsigned char&gt;&amp; input) {\n        write_bytes(&amp;input[0], input.size());\n    }\n\n    std::string read_str(unsigned int read_size_in_bytes) {\n        std::string output = std::string();\n        output.resize(read_size_in_bytes);\n        file.read(&amp;output[0], read_size_in_bytes);\n        return output;\n    }\n    void write_str(std::string&amp; str) {\n        file.write(&amp;str[0], str.length());\n    }\n\n    void write_int32(int val) {\n        int* val_pointer = &amp;val;\n        char* char_pointer = reinterpret_cast&lt;char*&gt;(val_pointer); // convert int* to char* without changing position\n        std::vector&lt;char&gt; bytes = {char_pointer[0], char_pointer[1], char_pointer[2], char_pointer[3]};\n        write_bytes(bytes);\n    }\n    int read_int32() {\n        std::vector&lt;char&gt; bytes = read_bytes(4);\n        char* char_pointer = &amp;bytes[0];\n        int* val_pointer = reinterpret_cast&lt;int*&gt;(char_pointer);\n        return *val_pointer;\n    }\n\n    unsigned int read_uint32() {\n        std::vector&lt;char&gt; bytes = read_bytes(4);\n        char* char_pointer = &amp;bytes[0];\n        unsigned int* val_pointer = reinterpret_cast&lt;unsigned int*&gt;(char_pointer);\n        return *val_pointer;\n    }\n\n    unsigned char read_uint8() {\n        std::vector&lt;char&gt; bytes = read_bytes(1);\n        char* char_pointer = &amp;bytes[0];\n        unsigned char* val_pointer = reinterpret_cast&lt;unsigned char*&gt;(char_pointer);\n        return *val_pointer;\n    }\n\n    char read_int8() {\n        std::vector&lt;char&gt; bytes = read_bytes(1);\n        char* char_pointer = &amp;bytes[0];\n        char* val_pointer = reinterpret_cast&lt;char*&gt;(char_pointer);\n        return *val_pointer;\n    }\n\n    std::string read_word() {\n        std::string output = std::string();\n        file &gt;&gt; output;\n        return output;\n    }\n    std::string read_next_line() {\n        std::string output = std::string();\n        std::getline(file, output, '\\n');\n        return output;\n    }\n    bool end_of_file() {\n        return file.eof();\n    }\n    void erase_file_contents() {\n        file.close();\n        file.open(filename, std::ios::trunc | std::ios::out | std::ios::in | std::ios::binary);\n        if(!file_is_open()) {\n            std::cout &lt;&lt; \"file could not open!\" &lt;&lt; std::endl;\n            throw;\n        }\n        else {\n            //std::cout &lt;&lt; \"file opened successfully\" &lt;&lt; std::endl;\n        }\n    }\n    // NOTE! This will move the read/write position\n    unsigned int get_file_size() {\n        file.seekg( 0, std::ios::end );\n        return get_read_write_position();\n    }\n};\n</code></pre>"},{"location":"cpp_std/#get-time-since-epoch","title":"Get time since epoch","text":"<pre><code>/**\n * Returns the time since epoch in seconds, \n * NOTE! Different behaviour on different devices\n * on some devices epoch refers to January 1: 1970, \n * on other devices epoch might refer to time since last boot\n*/\ndouble get_time_since_epoch_s() {\n    using namespace std::chrono;\n    auto time = duration_cast&lt;nanoseconds&gt;(high_resolution_clock::now().time_since_epoch());\n    double nano_secs = time.count();\n    return nano_secs / (1000.0 * 1000.0 * 1000.0);\n}\ndouble get_time_since_epoch_ms() {\n    return get_time_since_epoch_s() * 1000;\n}\n</code></pre>"},{"location":"cpp_std/#sleep","title":"Sleep","text":"<pre><code>void sleep_s(double sleep_time_s) {\n    double time_ms = sleep_time_s * 1000;\n    std::this_thread::sleep_for(std::chrono::milliseconds((int64_t)time_ms));\n}\n</code></pre> <pre><code>void TEST_sleep() {\n    double start_time = get_time_since_epoch_s();\n    sleep_s(0.7);\n    double end_time = get_time_since_epoch_s();\n    double duration = end_time - start_time;\n    AssertEq(duration, 0.7, 0.1);\n}\n</code></pre>"},{"location":"cpp_std/#pi","title":"PI","text":"<pre><code>const double PI  = 3.141592653589793238463;\n</code></pre>"},{"location":"cpp_std/#is-power-of-2","title":"Is power of 2","text":"<pre><code>inline bool is_power_of_two(unsigned int x) {\n    return !(x == 0) &amp;&amp; !(x &amp; (x - 1));\n}\ninline bool is_power_of_two(int x) {\n    return !(x == 0) &amp;&amp; !(x &amp; (x - 1));\n}\n</code></pre>"},{"location":"cpp_std/#upper-power-of-2","title":"Upper power of 2","text":"<pre><code>unsigned int upper_power_of_two(unsigned int x) {\n    int power = 1;\n    while(power &lt; x) {\n        power*=2;\n    }\n    return power;\n}\n</code></pre>"},{"location":"cpp_std/#modulo","title":"Modulo","text":"<pre><code>double modulo(double val, double mod) {\n    if(val &gt; 0) {\n        return val - ((int)(val / mod)) * mod;\n    }\n    else {\n        return val - ((int)((val-0.0000001) / mod) - 1) * mod;\n    }\n}\n</code></pre>"},{"location":"cpp_std/#degrees-radians-conversion","title":"Degrees radians conversion","text":"<pre><code>double degrees_to_radians(const double deg) {\n    const double PI  = 3.141592653589793238463;\n    return deg * 2.0 * PI / 360.0;\n}\n\ndouble radians_to_degrees(const double rad) {\n    const double PI  = 3.141592653589793238463;\n    return rad * 360.0 / (PI * 2.0);\n}\n</code></pre>"},{"location":"cpp_std/#in-range","title":"In range","text":"<pre><code>/**\n * Determine if a value is in range\n * Returns true if min_v &lt;= v &lt;= max_v\n*/\ntemplate&lt;class T&gt;\ninline bool in_range(T v, T min_v, T max_v) {\n    if(v &lt; min_v) {\n        return false;\n    }\n    if(v &gt; max_v) {\n        return false;\n    }\n    return true;\n}\n</code></pre>"},{"location":"cpp_std/#vector-operations","title":"Vector operations","text":"<pre><code>/**\n * Determine if a value exists somewhere in a vector\n * @param val The value to look for\n * @param vec The vector to look in\n * @return Returns true if value is somewhere in vector, otherwise returns false\n*/\ntemplate&lt;class T&gt;\nbool in_vector(T val, std::vector&lt;T&gt;&amp; vec) {\n    for(int i = 0; i &lt; vec.size(); i++) {\n        if(val == vec[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\ndouble get_min_in_vector(std::vector&lt;double&gt; vec) {\n    double min_val = vec[0];\n    for(int i = 0; i &lt; vec.size(); i++) {\n        if(vec[i] &lt; min_val) {\n            min_val = vec[i];\n        }\n    }\n    return min_val;\n}\n\ndouble get_max_in_vector(std::vector&lt;double&gt; vec) {\n    double max_val = vec[0];\n    for(int i = 0; i &lt; vec.size(); i++) {\n        if(vec[i] &gt; max_val) {\n            max_val = vec[i];\n        }\n    }\n    return max_val;\n}\n\ntemplate &lt;class T&gt;\nT vec_sum(const std::vector&lt;T&gt;&amp; vec, T zero_element) {\n    T sum = zero_element;\n    for(int i = 0; i &lt; vec.size(); i++) {\n        sum += vec[i];\n    }\n    return sum;\n}\n\ntemplate &lt;class T&gt;\nT vec_sum(const std::vector&lt;T&gt;&amp; vec) {\n    return vec_sum(vec, (T)0);\n}\n\ntemplate &lt;class T&gt;\nvoid vec_sort_ascend(std::vector&lt;T&gt;&amp; vec) {\n    std::sort(vec.begin(), \n        vec.end(), \n        [](const T&amp; lhs, const T&amp; rhs) {\n            return lhs &lt; rhs;\n    });\n}\n\ntemplate &lt;class T&gt;\nvoid vec_sort_descend(std::vector&lt;T&gt;&amp; vec) {\n    std::sort(vec.begin(), \n        vec.end(), \n        [](const T&amp; lhs, const T&amp; rhs) {\n            return lhs &gt; rhs;\n    });\n}\n\ntemplate &lt;class T&gt;\nstd::vector&lt;std::pair&lt;T, int&gt;&gt; vec_to_pair_with_indecies(const std::vector&lt;T&gt;&amp; vec) {\n    std::vector&lt;std::pair&lt;T, int&gt;&gt; return_vec = {};\n    for(int i = 0; i &lt; vec.size(); i++) {\n        std::pair&lt;T, int&gt; pair_;\n        pair_.first = vec[i];\n        pair_.second = i;\n        return_vec.push_back(pair_);\n    }\n    return return_vec;\n}\ntemplate &lt;class T&gt;\nstd::vector&lt;std::pair&lt;T, int&gt;&gt; vec_sort_ascend_and_get_indecies(const std::vector&lt;T&gt;&amp; vec) {\n    std::vector&lt;std::pair&lt;T, int&gt;&gt; return_vec = vec_to_pair_with_indecies(vec);\n    std::sort(return_vec.begin(), \n        return_vec.end(), \n        [](const std::pair&lt;T, int&gt;&amp; lhs, const std::pair&lt;T, int&gt;&amp; rhs) {\n            return lhs.first &lt; rhs.first;\n    });\n    return return_vec;\n}\ntemplate &lt;class T&gt;\nstd::vector&lt;std::pair&lt;T, int&gt;&gt; vec_sort_descend_and_get_indecies(const std::vector&lt;T&gt;&amp; vec) {\n    std::vector&lt;std::pair&lt;T, int&gt;&gt; return_vec = vec_to_pair_with_indecies(vec);\n    std::sort(return_vec.begin(), \n        return_vec.end(), \n        [](const std::pair&lt;T, int&gt;&amp; lhs, const std::pair&lt;T, int&gt;&amp; rhs) {\n            return lhs.first &gt; rhs.first;\n    });\n    return return_vec;\n}\n\ntemplate &lt;class T&gt;\nvoid vec_remove(std::vector&lt;T&gt;&amp; vec, std::size_t pos)\n{\n    auto it = vec.begin();\n    std::advance(it, pos);\n    vec.erase(it);\n}\n\n/**\nExtend one vector with another(can also be referred to as vector adding or concatenation)\nextend_vec({1, 2}, {3, 4, 5}) -&gt; {1, 2, 3, 4, 5}\n@arg vec: the first vector\n@arg add_vec: the vector to add to vec\n*/\ntemplate &lt;class T&gt;\nvoid vec_extend(std::vector&lt;T&gt;&amp; vec, const std::vector&lt;T&gt;&amp; vec_add){\n    vec.insert(vec.end(), vec_add.begin(), vec_add.end());\n}\n\n/**\nExtend one vector with another(can also be referred to as vector adding or concatenation)\nextend_vec({1, 2}, {3, 4, 5}) -&gt; {1, 2, 3, 4, 5}\n@arg vec: the first vector\n@arg add_vec: the vector to add to vec\n*/\ntemplate &lt;class T&gt;\nvoid vec_insert(std::vector&lt;T&gt;&amp; vec,int index, T val){\n    vec.insert(vec.begin()+index, val);\n}\n</code></pre>"},{"location":"cpp_std/#emscripten-support","title":"Emscripten support","text":"<pre><code>// Some functions to make working with emscripten easier, should also work without emscripten to make it cross platform\nstatic vicmil::void_function_type update_func_ptr = nullptr;\nstatic vicmil::void_function_type init_func_ptr = nullptr;\nvoid main_app_update() {\n    static bool inited = false;\n    if(!inited) {\n        inited = true;\n        if(init_func_ptr != nullptr) {\n            init_func_ptr();\n        }\n    }\n    if(update_func_ptr != nullptr) {\n        update_func_ptr();\n    }\n}\nvoid set_app_update(vicmil::void_function_type func_ptr_) {\n    update_func_ptr = func_ptr_;\n}\nvoid set_app_init(vicmil::void_function_type func_ptr_) {\n    init_func_ptr = func_ptr_;\n}\nvoid app_start() {\n    #ifdef EMSCRIPTEN\n        emscripten_set_main_loop(main_app_update, 0, 1);\n    #else\n        while(true) {\n            main_app_update();\n        }\n    #endif\n}\n</code></pre> <pre><code>// Example usage\nvoid init() { \n    // do init stuff here, will be called once at the start of the program\n    std::cout &lt;&lt; \"init\" &lt;&lt; std::endl;\n} \nvoid update() {\n    // do update stuff here, will be called continously\n    std::cout &lt;&lt; \"update\" &lt;&lt; std::endl;\n} \n\n// This makes it work cross platform with emscripten compiler, if compiling for the web\n// Stems from the fact that if you do a while loop, the whole browser freezes, so you need to give back \n// control to javascript after each update, which is here done for you automatically :)\nint main(int argc, char *argv[]) {\n    vicmil::set_app_update(update);\n    vicmil::set_app_init(init);\n    vicmil::app_start();\n    return 0;\n}\n</code></pre>"},{"location":"cpp_std/#typing","title":"Typing","text":"<pre><code> template &lt;typename T, typename U&gt;\ninline bool equals(const std::weak_ptr&lt;T&gt;&amp; t, const std::weak_ptr&lt;U&gt;&amp; u)\n{\n    return !t.owner_before(u) &amp;&amp; !u.owner_before(t);\n}\n\ntemplate &lt;typename T, typename U&gt;\ninline bool equals(const std::weak_ptr&lt;T&gt;&amp; t, const std::shared_ptr&lt;U&gt;&amp; u)\n{\n    return !t.owner_before(u) &amp;&amp; !u.owner_before(t);\n}\n\ntemplate&lt;class T&gt;\nstd::type_index _get_type_index() {\n    return std::type_index(typeid(T));\n}\ntemplate&lt;class T&gt;\nstd::string type_to_str() {\n    std::type_index typ = _get_type_index&lt;T&gt;();\n    std::string name = typ.name();\n    return name;\n}\ntemplate&lt;class T&gt;\nint64_t type_to_int() {\n    std::type_index typ = _get_type_index&lt;T&gt;();\n    std::size_t code = typ.hash_code();\n    return (int64_t)code;\n}\ntemplate&lt;class T&gt;\nint64_t type_to_int(T* _) {\n    return type_to_int&lt;T&gt;();\n}\ntemplate&lt;class T&gt;\nT* null_if_type_missmatch(T* v, int64_t type_int) {\n    if(type_to_int&lt;T&gt;() == type_int) {\n        return v;\n    }\n    return nullptr;\n}\n</code></pre>"},{"location":"cpp_std/#using-python-to-build-c-projects","title":"Using Python to build C++ projects","text":"<p>NOTE! Implementation not complete: TODO</p> <pre><code>class BuildSetup:\n    def __init__(self, cpp_file_paths: List[str], browser = False):\n        # When building c++ projects, this is in general the order the flags should be\n        self.n1_compiler_path = get_default_compiler_path(browser = browser)\n        self.n2_cpp_files = '\"' + '\" \"'.join(cpp_file_paths) + '\"'\n        self.n3_optimization_level = \"\"\n        self.n4_macros = \"\"\n        self.n5_additional_compiler_settings = \"\"\n        self.n6_include_paths = \"\"\n        self.n7_library_paths = \"\"\n        self.n8_library_files = \"\"\n        self.n9_output_file = get_default_output_file(browser=browser)\n\n        # If the target platform is the browser\n        self.browser_flag = browser\n\n    def include_opengl(self): # Opengl is a cross platform graphics library that also works in the browser(with the right setup)\n        add_opengl_flags(self, self.browser_flag)\n\n    def enable_debug(self):\n        self.n4_macros += \" -D USE_DEBUG\"\n\n    def include_asio(self): # Asio is a cross platform networking library to work with sockets etc.\n        add_asio_flags(self, browser=self.browser_flag)\n\n    def generate_build_command(self):\n        arguments = [\n            self.n1_compiler_path, \n            self.n2_cpp_files,\n            self.n3_optimization_level,\n            self.n4_macros,\n            self.n5_additional_compiler_settings,\n            self.n6_include_paths,\n            self.n7_library_paths,\n            self.n8_library_files,\n            \"-o \" + '\"' + self.n9_output_file + '\"',\n        ]\n\n        # Reomve arguments with length 0\n        arguments = filter(lambda arg: len(arg) &gt; 0, arguments)\n\n        return \" \".join(arguments)\n\n\n    def build_and_run(self):\n        build_command = self.generate_build_command()\n\n        # Remove the output file if it exists already\n        if file_exist(self.n9_output_file):\n            delete_file(self.n9_output_file)\n\n        # Run the build command\n        print(build_command)\n        run_command(build_command)\n\n        invoke_file(self.n9_output_file)\n\n\ndef run_command(command: str) -&gt; None:\n    \"\"\"Run a command in the terminal\"\"\"\n    platform_name = platform.system()\n    if platform_name == \"Windows\": # Windows\n        if command[0] != '\"':\n            os.system(f'powershell; {command}')\n        else:\n            os.system(f'powershell; &amp;{command}')\n    else:\n        os.system(command)\n\n\ndef invoke_file(file_path: str):\n    if not file_exist(file_path=file_path):\n        print(file_path + \" does not exist\")\n\n    file_extension = file_path.split(\".\")[-1]\n\n    if file_extension == \"html\":\n        # Create a local python server and open the file in the browser\n        launch_html_page(file_path)\n\n    elif file_extension == \"exe\" or file_extension == \"out\":\n        # Navigate to where the file is located and invoke the file\n        file_directory = path_traverse_up(file_path, 0)\n        change_active_directory(file_directory)\n        run_command('\"' + file_path + '\"')\n\n\n# Get the defualt compiler path within vicmil lib\ndef get_default_compiler_path(browser = False):\n    platform_name = platform.system()\n\n    if not browser:\n        if platform_name == \"Windows\": # Windows\n            return '\"' + path_traverse_up(__file__, 1) + \"/deps/win_/mingw64/bin/g++\" + '\"'\n        else:\n            return \"g++\"\n\n    else:\n        if platform_name == \"Windows\": # Windows\n            return '\"' + path_traverse_up(__file__, 1) + \"/deps/win_/emsdk/upstream/emscripten/em++.bat\" + '\"'\n        else:\n            return '\"' + path_traverse_up(__file__, 1) + \"/deps/linux_/emsdk/upstream/emscripten/em++\" + '\"'\n\n\ndef add_opengl_flags(build_setup: BuildSetup, browser = False):\n    if not browser:\n        platform_name = platform.system()\n\n        if platform_name == \"Windows\": # Windows\n            dependencies_directory = path_traverse_up(__file__, 1) + \"/deps/win_\"\n\n            # SDL\n            build_setup.n6_include_paths += ' -I\"' + dependencies_directory + \"/sdl_mingw/SDL2-2.30.7/x86_64-w64-mingw32/include/SDL2\" + '\"'\n            build_setup.n6_include_paths += ' -I\"' + dependencies_directory + \"/sdl_mingw/SDL2-2.30.7/x86_64-w64-mingw32/include\" + '\"'\n            build_setup.n7_library_paths += ' -L\"' + dependencies_directory + \"/sdl_mingw/SDL2-2.30.7/x86_64-w64-mingw32/lib\" + '\"'\n\n            # SDL_image\n            build_setup.n6_include_paths += ' -I\"' + dependencies_directory + \"/sdl_mingw/SDL2_image-2.8.2/x86_64-w64-mingw32/include\" + '\"'\n            build_setup.n7_library_paths += ' -L\"' + dependencies_directory + \"/sdl_mingw/SDL2_image-2.8.2/x86_64-w64-mingw32/lib\" + '\"'\n\n            # Glew\n            build_setup.n6_include_paths += ' -I\"' + dependencies_directory + \"/glew-2.2.0/include\" + '\"'\n            build_setup.n7_library_paths += ' -L\"' + dependencies_directory + \"/glew-2.2.0/lib/Release/x64\" + '\"'\n\n            build_setup.n8_library_files += ' -l' + \"mingw32\"\n            build_setup.n8_library_files += ' -l' + \"glew32\"\n            build_setup.n8_library_files += ' -l' + \"opengl32\"\n            build_setup.n8_library_files += ' -l' + \"SDL2main\"\n            build_setup.n8_library_files += ' -l' + \"SDL2\"\n            build_setup.n8_library_files += ' -l' + \"SDL2_image\"\n\n        elif platform_name == \"Linux\": # Linux\n            build_setup.n6_include_paths += ' -I' + \"/usr/include\"\n\n            build_setup.n8_library_files += ' -l' + \"SDL2\"\n            build_setup.n8_library_files += ' -l' + \"SDL2_image\"\n            build_setup.n8_library_files += ' -l' + \"GL\"  #(Used for OpenGL on desktops)\n            build_setup.n8_library_files += ' -l' + \"SDL2_image\"\n\n        else:\n            raise NotImplementedError()\n\n    else:\n        build_setup.n5_additional_compiler_settings += \" -s USE_SDL=2\"\n        build_setup.n5_additional_compiler_settings += \" -s USE_SDL_IMAGE=2\"\n        build_setup.n5_additional_compiler_settings += \" -s EXTRA_EXPORTED_RUNTIME_METHODS=ccall,cwrap\"\n        # build_setup.n5_additional_compiler_settings += \"\"\" -s SDL2_IMAGE_FORMATS='[\"png\"]'\"\"\"\n        build_setup.n5_additional_compiler_settings += \" -s FULL_ES3=1\"\n\n\n# Asio is used for sockets and network programming\ndef add_asio_flags(build_setup: BuildSetup, browser = False):\n    if browser:\n        raise Exception(\"Asio is not supported for the browser, consider using websockets bindings to javascript(TODO)\")\n\n    build_setup.n6_include_paths += ' -I\"' + path_traverse_up(__file__, 1) + \"/deps/external_libraries/asio/include\" + '\"'\n\n    platform_name = platform.system()\n    if platform_name == \"Windows\": # Windows\n        build_setup.n8_library_files += \" -lws2_32\" # Needed to make it compile with mingw compiler\n\n    else:\n        print(\"asio include not implemented for \", platform_name)\n</code></pre>"},{"location":"git_commands/","title":"Usefull git commands","text":""},{"location":"git_commands/#create-a-new-branch-locally","title":"Create a new branch locally","text":"<pre><code>git checkout -b my_new_branch\n</code></pre>"},{"location":"git_commands/#create-a-new-branch-locally-without-any-commit-history","title":"Create a new branch locally without any commit history","text":"<pre><code>git checkout --orphan my_new_branch\n</code></pre>"},{"location":"git_commands/#create-a-new-branch-locally-with-commit-history","title":"Create a new branch locally with commit history","text":"<p><code>git checkout -b my_new_branch</code></p>"},{"location":"git_commands/#push-a-local-branch-to-upstream-if-upstream-branch-does-not-exist","title":"Push a local branch to upstream if upstream branch does not exist","text":"<pre><code>git push --set-upstream origin my_new_branch\n</code></pre>"},{"location":"git_commands/#overwrite-history-of-remote-repo-with-local-repo","title":"Overwrite history of remote repo with local repo","text":"<pre><code>git push origin my_new_branch --force\n</code></pre>"},{"location":"git_commands/#undo-last-commitonly-affecting-git-history-all-files-remain-the-same","title":"Undo last commit(only affecting git history, all files remain the same)","text":"<pre><code>git reset HEAD~1\n</code></pre>"},{"location":"git_commands/#delete-branch","title":"Delete branch","text":"<pre><code>git branch -D master\n</code></pre>"},{"location":"git_commands/#generate-a-new-ssh-key","title":"Generate a new ssh key","text":"<pre><code>ssh-keygen -t ed25519 -C \"your_email@example.com\"\n</code></pre>"},{"location":"git_commands/#push-local-code-to-new-branch-in-remote-repo","title":"Push local code to new branch in remote repo","text":"<p>Create git repo</p> <pre><code>git init\n</code></pre> <p>Create a new branch that you would like to push</p> <pre><code>git checkout -b my_new_branch\n</code></pre> <p>Set the repo to be connected to the remote repo you would like to push to</p> <pre><code>git remote add origin https://github.com/my_git_repo_to_use\n</code></pre> <p>Push the code to the remote repo and create a new remote branch</p> <pre><code>git push -u origin my_new_branch\n</code></pre>"},{"location":"git_commands/#unstage-files-for-commit","title":"Unstage files for commit","text":"<pre><code>git restore --staged &lt;file&gt;\n</code></pre>"},{"location":"python_docs/","title":"Using MKDocs for documentation","text":"<p>You can either just copy the parts that you find interesting, or download the following:</p> <ul> <li>setup_docs.py - Install the necessary pip packages in a virtual environment in ./env</li> <li>view_docs.py - Display the documentation in a browser window</li> </ul>"},{"location":"python_docs/#install","title":"Install","text":"<pre><code>pip install mkdocs, mkdocs-material, pymdown-extensions\n</code></pre>"},{"location":"python_docs/#mkdocs-new-project","title":"MKDocs new project","text":"<pre><code>def mkdocs_new(project_name):\n    from mkdocs.utils import write_file\n    # Create the project directory and docs directory\n    os.makedirs(os.path.join(project_name, \"docs\"), exist_ok=True)\n\n    # Write default mkdocs.yml file\n    config_content = \"site_name: My Docs\\n\"\n    write_file(config_content.encode('utf-8'), os.path.join(project_name, \"mkdocs.yml\"))\n\n    # Write default index.md file\n    index_content = \"# Welcome to MkDocs\\n\\nThis is your homepage!\"\n    write_file(index_content.encode('utf-8'), os.path.join(project_name, \"docs\", \"index.md\"))\n\n    print(f\"New MkDocs project created in: {project_name}\")\n\nmkdocs_new(\"my-new_project\")\n</code></pre>"},{"location":"python_docs/#mkdocs-serve-project","title":"MKDocs serve project","text":"<p>Makes it so you can view the project in the browser if you navigate to \"http://127.0.0.1:8000\"</p> <pre><code>def serve_mkdocs_project(config_file=\"mkdocs.yml\", host=\"127.0.0.1\", port=8000):\n    \"\"\"\n    Serve an MkDocs project locally.\n\n    Args:\n        config_file (str): Path to the mkdocs.yml configuration file.\n        host (str): Host address to bind the server (default: 127.0.0.1).\n        port (int): Port number to serve the site (default: 8000).\n    \"\"\"\n    from mkdocs.commands.serve import serve\n    try:\n        # Start the MkDocs development server directly with the configuration file\n        print(f\"Serving MkDocs at http://{host}:{port}\")\n        serve(config_file, host=host, port=port, livereload=True, watch_theme=True)\n    except KeyboardInterrupt:\n        print(\"\\nServer stopped.\")\n</code></pre>"},{"location":"python_docs/#go-to-url","title":"Go to url","text":"<p>Opens the webbrowser with the provided url</p> <pre><code>def go_to_url(url: str):\n    import webbrowser\n    webbrowser.open(url, new=0, autoraise=True)\n</code></pre>"},{"location":"python_docs/#mkdocs-launch-example","title":"Mkdocs launch example","text":"<pre><code># Setup virtual environment and install everything necessary\nvirtual_env_path = vicmil_pysetup.get_directory(__file__) + \"/env\"\n\nvicmil_pysetup.python_virtual_environment(virtual_env_path)\nvicmil_pysetup.pip_install_packages_in_virtual_environment(\n    env_directory_path=virtual_env_path,\n    packages=[\"mkdocs\", \"mkdocs-material\", \"pymdown-extensions\"]\n)\n</code></pre> <pre><code># Create new docs project, and show it in the webbrowser\nmkdocs_new(\"my-new-docs\")\nvicmil_pysetup.set_active_directory(\"my-new-docs\")\ngo_to_url(\"http://127.0.0.1:8000\")\nserve_mkdocs_project()\n</code></pre>"},{"location":"python_docs/#build-mkdocs","title":"Build MKdocs","text":"<p>Builds it into html files that can be hosted as a server</p> <pre><code>def build_mkdocs_documentation(config_file=\"mkdocs.yml\", output_dir=None):\n    from mkdocs.config import load_config\n    from mkdocs.commands.build import build\n    \"\"\"\n    Build MkDocs documentation into a static site.\n\n    Args:\n        config_file (str): Path to the mkdocs.yml configuration file.\n        output_dir (str): Optional. Path to the output directory for the built site.\n    \"\"\"\n    # Load the MkDocs configuration\n    config = load_config(config_file)\n\n    # Set a custom output directory if provided\n    if output_dir:\n        config['site_dir'] = os.path.abspath(output_dir)\n\n    try:\n        print(f\"Building documentation using config: {config_file}\")\n        build(config)\n        print(f\"Documentation successfully built in: {config['site_dir']}\")\n    except Exception as e:\n        print(f\"Error while building documentation: {e}\")\n</code></pre>"},{"location":"python_docs/#start-a-python-server-in-the-current-directory","title":"Start a python server in the current directory","text":"<pre><code>python -m http.server\n</code></pre>"},{"location":"python_docs/#example-for-building-and-running-documentation","title":"Example for building and running documentation","text":"<pre><code>set_active_directory(get_directory(__file__) + \"/docs_common\")\ngo_to_url(\"http://127.0.0.1:8000\")\nbuild_mkdocs_documentation()\nset_active_directory(get_directory(__file__) + \"/docs_common/site\")\ntry:\n    os.system(\"python3 -m http.server\")\nexcept Exception as e:\n    pass\n\nos.system(\"python -m http.server\")\n</code></pre>"},{"location":"python_setup/","title":"Documentation for python project setup","text":""},{"location":"python_setup/#introduction","title":"Introduction","text":"<p>This document provides some code for how to setup and start a python project, such as</p> <ul> <li>Path functionality</li> <li>Creating a virtual environment</li> <li>Downloading things from git</li> <li>Setting up documenation for the project</li> </ul> <p>You can either just copy the parts that you find interesting, or download the following:</p> <ul> <li>python_setup.py</li> </ul>"},{"location":"python_setup/#enable-importing-from-current-directory","title":"Enable importing from current directory","text":"<pre><code># Add current directory to import path\nimport sys, pathlib\nsys.path.append(str(pathlib.Path(__file__).resolve().parents[0]))\n</code></pre>"},{"location":"python_setup/#path-traverse-up","title":"Path Traverse Up","text":"<pre><code>def path_traverse_up(path: str, count: int) -&gt; str:\n    \"\"\"Traverse the provided path upwards\n\n    Parameters\n    ----------\n        path (str): The path to start from, tips: use __file__ to get path of the current file\n        count (int): The number of directories to go upwards\n\n    Returns\n    -------\n        str: The path after the traversal, eg \"/some/file/path\"\n    \"\"\"\n\n    parents = pathlib.Path(path).parents\n    path_raw = str(parents[count].resolve())\n    return path_raw.replace(\"\\\\\", \"/\")\n\nparent_directory = path_traverse_up(__file__, 1)\n</code></pre>"},{"location":"python_setup/#get-directory","title":"Get directory","text":"<pre><code>def get_directory(file_path: str):\n    return str(pathlib.Path(file_path).parents[0].resolve()).replace(\"\\\\\", \"/\")\n\ncurrent_directory = get_directory(__file__)\n</code></pre>"},{"location":"python_setup/#set-active-directory","title":"Set active directory","text":"<pre><code>def set_active_directory(path):\n    os.chdir(path)\n</code></pre>"},{"location":"python_setup/#clear-file","title":"Clear file","text":"<pre><code>def clear_file(file_path):\n     with open(file_path, \"w\") as log_file: # Remove any previous contents\n        pass\n</code></pre>"},{"location":"python_setup/#ensure-directory-exists","title":"Ensure directory exists","text":"<pre><code>def ensure_directory_exists(dir_path):\n    os.makedirs(dir_path, exist_ok=True)\n</code></pre>"},{"location":"python_setup/#ensure-file-exists","title":"Ensure file exists","text":"<pre><code>def ensure_file_exists(file_path):\n    file_directory = str(pathlib.Path(file_path).parents[0].resolve()).replace(\"\\\\\", \"/\")\n    os.makedirs(file_directory, exist_ok=True) # Ensure the parent directory exists\n    if not os.path.exists(file_path):\n        with open(file_path, \"w\") as _: # Create the file\n            pass\n</code></pre>"},{"location":"python_setup/#list-files-in-directory","title":"List files in directory","text":"<pre><code>def list_files_in_directory(dir_path):\n    return os.listdir(dir_path)\n</code></pre>"},{"location":"python_setup/#set-ssh-key-for-git","title":"Set ssh key for git","text":"<pre><code>def set_git_ssh_key_path(ssh_key_path): # Set the ssh key for git\n    if not os.path.exists(ssh_key_path):\n        print(\"ssh key does not exist!\")\n        return\n    else:\n        print(\"found valid ssh key\")\n        os.environ[\"GIT_SSH_COMMAND\"] = f\"ssh -i {ssh_key_path}\"\n</code></pre>"},{"location":"python_setup/#git-fetch","title":"Git fetch","text":"<pre><code>def git_fetch(dir_path, ssh_key_path = None):\n    \"\"\"\n    Checks for new updates in the specified directory be doing a git fetch\n    Returns true if any updates were available, otherwise returns false\n    \"\"\"\n\n    try:\n        os.chdir(dir_path) # Set active directory\n        if ssh_key_path:\n            if not os.path.exists(ssh_key_path): # Try and setup ssh key for git\n                print(\"ssh key does not exist!\")\n                return\n            else:\n                print(\"found valid ssh key\")\n                os.environ[\"GIT_SSH_COMMAND\"] = f\"ssh -i {ssh_key_path}\"\n\n        print(\"git fetch\")\n        # Fetch the latest changes\n        subprocess.run([\"git\", \"fetch\"], check=True)\n\n        # Compare local and remote branches\n        status = subprocess.run(\n            [\"git\", \"rev-list\", \"--count\", f\"HEAD..origin\"],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        updates_ahead = int(status.stdout.strip())\n\n        print(\"updates_ahead: \", updates_ahead)\n\n        return updates_ahead &gt; 0\n    except Exception as e:\n        print(e)\n        print(\"could not fetch updates\")\n</code></pre>"},{"location":"python_setup/#git-pull","title":"Git pull","text":"<pre><code>def git_pull(dir_path, ssh_key_path = None):\n    \"\"\"\n    Performs git pull in a directory\n    \"\"\"\n    print(\"Downloading updates...\")\n    os.chdir(dir_path) # Set active directory\n    if ssh_key_path:\n        if not os.path.exists(ssh_key_path): # Try and setup ssh key for git\n            print(\"ssh key does not exist!\")\n            return\n        else:\n            print(\"found valid ssh key\")\n            os.environ[\"GIT_SSH_COMMAND\"] = f\"ssh -i {ssh_key_path}\"\n\n    # Pull the latest changes\n    os.system('git pull')\n</code></pre>"},{"location":"python_setup/#git-clone","title":"Git clone","text":"<pre><code>def git_clone(dir_path, git_repo, ssh_key_path = None):\n    os.chdir(dir_path) # Set active directory\n    if ssh_key_path:\n        if not os.path.exists(ssh_key_path): # Try and setup ssh key for git\n            print(\"ssh key does not exist!\")\n            return\n        else:\n            print(\"found valid ssh key\")\n            os.environ[\"GIT_SSH_COMMAND\"] = f\"ssh -i {ssh_key_path}\"\n\n    os.system(f'git clone {git_repo}')\n</code></pre>"},{"location":"python_setup/#python-virtual-environment","title":"Python virtual environment","text":"<pre><code>def python_virtual_environment(env_directory_path):\n    # Setup a python virtual environmet\n    os.makedirs(env_directory_path, exist_ok=True) # Ensure directory exists\n    my_os = platform.system()\n    if my_os == \"Windows\":\n        os.system(f'python -m venv \"{env_directory_path}\"')\n    else:\n        os.system(f'python3 -m venv \"{env_directory_path}\"')\n</code></pre>"},{"location":"python_setup/#python-install-requirements-in-virtual-environment","title":"Python install requirements in virtual environment","text":"<pre><code>def pip_install_requirements_file_in_virtual_environment(env_directory_path, requirements_path):\n    if not os.path.exists(env_directory_path):\n        print(f\"Invalid path: {env_directory_path}\")\n        raise Exception(\"Invalid path\")\n\n    if not os.path.exists(requirements_path):\n        print(f\"Invalid path: {requirements_path}\")\n        raise Exception(\"Invalid path\")\n\n    my_os = platform.system()\n    if my_os == \"Windows\":\n         os.system(f'powershell; &amp;\"{env_directory_path}/Scripts/pip\" install -r \"{requirements_path}\"')\n    else:\n        os.system(f'\"{env_directory_path}/bin/pip\" install -r \"{requirements_path}\"')\n</code></pre>"},{"location":"python_setup/#python-install-packages-in-virtual-environment","title":"Python install packages in virtual environment","text":"<pre><code>def pip_install_packages_in_virtual_environment(env_directory_path, packages):\n    if not os.path.exists(env_directory_path):\n        print(\"Invalid path\")\n        raise Exception(\"Invalid path\")\n\n    my_os = platform.system()\n    for package in packages:\n        if my_os == \"Windows\":\n            os.system(f'powershell; &amp;\"{env_directory_path}/Scripts/pip\" install {package}')\n        else:\n            os.system(f'\"{env_directory_path}/bin/pip\" install {package}')\n</code></pre>"},{"location":"python_setup/#subprocess-is-running","title":"Subprocess Is Running","text":"<pre><code>def process_is_running(p: subprocess.Popen):\n    if not p:\n        return False\n\n    poll = p.poll()\n    if poll is None:\n        return True # The process is running\n\n    return False\n</code></pre>"},{"location":"python_setup/#terminate-subprocess-and-all-its-children","title":"Terminate subprocess and all its children","text":"<pre><code>def terminate_process_and_all_its_children(p: subprocess.Popen):\n    import psutil\n    pid = p.pid\n    try:\n        parent = psutil.Process(pid)\n        children = parent.children(recursive=True)  # Get all descendants\n        for child in children:\n            child.terminate()  # Terminate each child process\n        parent.terminate()  # Terminate the parent process\n\n        # Wait for processes to exit\n        gone, alive = psutil.wait_procs(children + [parent], timeout=5)\n        for proc in alive:\n            proc.kill()  # Force kill if still alive\n    except psutil.NoSuchProcess:\n        print(f\"Process {pid} does not exist.\")\n</code></pre>"},{"location":"python_setup/#invoke-python-file-using-subprocess","title":"Invoke python file using subprocess","text":"<pre><code>def invoke_python_file_using_subprocess(python_env_path: str, file_path: str, logfile_path: str = None) -&gt; subprocess.Popen:\n    if not os.path.exists(python_env_path):\n        print(f\"invalid path: {python_env_path}\")\n\n    if not os.path.exists(file_path):\n        print(f\"invalid path: {file_path}\")\n\n    current_directory = str(pathlib.Path(file_path).parents[0].resolve()).replace(\"\\\\\", \"/\")\n    os.chdir(current_directory) # Set active directory to the current directory\n\n    command = \"\"\n    my_os = platform.system()\n    if logfile_path:\n        if my_os == \"Windows\":\n            command = f'powershell; &amp;\"{python_env_path}/Scripts/python\" -u \"{file_path}\" &gt; \"{logfile_path}\"'\n        else:\n            command = f'\"{python_env_path}/bin/python\" -u \"{file_path}\" &gt; \"{logfile_path}\"'\n    else:\n        if my_os == \"Windows\":\n            command = f'powershell; &amp;\"{python_env_path}/Scripts/python\" -u \"{file_path}\"'\n        else:\n            command = f'\"{python_env_path}/bin/python\" -u \"{file_path}\"'\n\n    new_process = subprocess.Popen(command, shell=True)\n    return new_process\n</code></pre>"},{"location":"python_setup/#print-logfile-in-real-time","title":"Print logfile in real-time","text":"<pre><code>def print_logs_loop(log_files: List[str]):\n    \"\"\"Continuously watch multiple log files\"\"\"\n    if type(log_files) == type(str(\"\")):\n        log_files = [log_files]\n\n    log_file_last_size = dict()\n    for LOG_FILE in log_files:\n        log_file_last_size[LOG_FILE] = 0\n\n    while True:\n        time.sleep(1)  # Polling interval (adjust as needed)\n        for LOG_FILE in log_files:\n            try:\n                if os.path.exists(LOG_FILE):\n                    current_size = os.path.getsize(LOG_FILE)\n                    if current_size == 0:\n                        log_file_last_size[LOG_FILE] = 0\n                    if current_size &gt; log_file_last_size[LOG_FILE]:  # Check if new data is added\n                        with open(LOG_FILE, \"r\") as log_file:\n                            log_file.seek(log_file_last_size[LOG_FILE])  # Start reading from last read position\n                            new_logs = log_file.read()\n                            log_file_last_size[LOG_FILE] = current_size\n                            print(new_logs[:-1]) # skip the last endl character\n            except Exception as e:\n                print(f\"Error reading logs: {e}\")\n\n# Print out the contents of the log files in real time\ndef create_log_file_tail_thread(log_files: List[str]):\n    print(\"tail_log_files\")\n    return threading.Thread(target=print_logs_loop, daemon=True, args=(log_files,)).start();\n</code></pre>"},{"location":"python_setup/#create-a-server-that-you-can-navigate-to-using-the-browser","title":"Create a server that you can navigate to using the browser","text":"<pre><code>python -m http.server\n</code></pre>"},{"location":"python_setup/#get-the-python-install-directory","title":"Get the python install directory","text":"<pre><code>python -c \"import sys; print(sys.executable)\"\n</code></pre>"},{"location":"server_setup/","title":"Server","text":""},{"location":"server_setup/#how-to-setup-and-manage-your-own-server","title":"How to setup and manage your own server","text":"<p>Note! This is just one way to do it that I have found to work well</p> <p>This method uses</p> <ul> <li>Amazon lightsail - for cheap server hosting (3.5 - 5$ per month)</li> <li>Amazon lambda - to manage the server, such as shutdown when limits are reached (free up to a certain quota per month)</li> <li>Cloudflare - for getting a domain, and to protect the server (5$/year for the domain)</li> <li>nginx - to setup server routing locally, and for enabling https (free)</li> <li>certbot - to install ssl certificate to enable https (free)</li> <li>Flask - backend server using python (free)</li> </ul>"},{"location":"server_setup/#common-links","title":"Common Links","text":"<ul> <li>Lightsail server instances: https://lightsail.aws.amazon.com/ls/webapp/home/instances</li> <li>Cloudflare homepage: https://dash.cloudflare.com/</li> <li> <p>AWS controll panel: https://eu-north-1.console.aws.amazon.com/console/home?region=eu-north-1</p> <p><code>The main control panel, from here you can navigate to everywhere else using the search bar in the top left</code></p> </li> <li> <p>AWS Lambda functions: https://eu-north-1.console.aws.amazon.com/lambda/home?region=eu-north-1#/functions</p> <p><code>Create python scripts that are triggered when events happen</code></p> </li> <li> <p>AWS CloudWatch: https://eu-north-1.console.aws.amazon.com/cloudwatch/home?region=eu-north-1#home</p> <p><code>Cloudwatch, where lambda function logs are stored, and where you can setup alarms and such</code></p> </li> <li> <p>AWS IAM: https://us-east-1.console.aws.amazon.com/iam/home?region=eu-north-1#/home</p> </li> </ul>"},{"location":"server_setup/#here-are-some-links-related-to-pricing","title":"Here are some links related to pricing","text":"<p>https://aws.amazon.com/free/compute/lightsail</p> <p>https://go.aws/49jYYpc</p>"},{"location":"server_setup/#related-articles","title":"Related Articles","text":"<p>How to setup https with certbot: https://dev.to/yousufbasir/setting-up-nginx-with-certbot-for-https-on-your-web-application-n1i</p>"},{"location":"server_setup/#nginx","title":"nginx","text":"<p>After you have installed nginx, it can be found in: <code>/etc/nginx/</code></p> <p>You will be able to add your config files for how the routing should work, setup https etc. in the <code>/etc/nginx/conf.d</code> directory</p>"},{"location":"server_setup/#commands","title":"Commands","text":"<p>Status nginx: <code>sudo systemctl status nginx</code></p> <p>Start nginx: <code>sudo systemctl start nginx</code></p> <p>Restart nginx: <code>sudo systemctl restart nginx</code></p> <p>Stop nginx: <code>sudo systemctl stop nginx</code></p>"},{"location":"server_setup/#other-usefull-commands-and-links","title":"Other usefull commands and links","text":"<p>Only allow cloudflare connections: https://www.cloudflare.com/ips/</p> <p><code>Set up server to only accept connections routed through cloudflare(configure firewall to only accept ip ranges from list)</code></p> <p>List all the current python processes: <code>ps -fA | egrep \"python|PID\"</code></p>"},{"location":"vscode_setup/","title":"VSCode Setup","text":""},{"location":"vscode_setup/#here-are-some-of-extensions-for-vscode-that-i-have-found-to-be-helpful","title":"Here are some of extensions for vscode that I have found to be helpful","text":"<p>TODO</p>"}]}